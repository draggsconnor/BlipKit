---
layout: doc
title: Manual
order: 10
---

## Library architecture

- [Context object](#context-object)
- [Track objects](#track-object)
- [Generating audio data](#generating-audio-data)
- [Attributes](#attributes)
- [Clocks and dividers](#clocks-and-dividers)

### Context object

[`BKContext`](context/) is the base object and controls the audio rendering. The number of required channels has to be defined at initialization (e.g. 2 for stereo). The sample rate should match that one which is used to output the audio, otherwise speed and pitch will not match.

{% highlight c %}
BKContext ctx;

// Initialize a context object with 2 channels (stereo)
// and a sample rate of 44100 Hz
BKContextInit (& ctx, 2, 44100);
{% endhighlight %}

### Track objects

[`BKTrack`](tracks/) objects render the audio data. This may be a waveform or a [sample](samples/). A [waveform](waveforms/) type has to be given at initialization which can be changed afterwards, though. Each track generates it own layer of sound data and doesn't interfere with other tracks.

{% highlight c %}
BKTrack track;

// Initialize a track object with a square wave
BKTrackInit (& track, BK_SQUARE);
{% endhighlight %}

In order to tell a track to render its audio data, it has to be attached to a context. Each context may have an arbitrary number of tracks attached to it.

{% highlight c %}
// Attach track to context
BKTrackAttach (& track, & ctx);
{% endhighlight %}

### Generating audio data

Audio data is generated by requesting an arbitary number of frames. This is done by calling either [`BKContextGenerate`](../context/#bkcontextgenerate), which fills a provided buffer with the requested number of frames, or its variant [`BKContextGenerateToTime`](../context/#bkcontextgeneratetotime), which outputs the frames to a provided callback.

A call to one of this functions advances each attached track's time by running its render function. The generated audio data of each tracks is then merged into the audio buffer. Subsequent calls to the generator functions generate the next requested number of frames.

A *frame* is a signed 16-bit integer which holds one single sample point.

{% highlight c %}
// Define an audio data buffer
// As there are two channels used, the buffer actually must be
// two times the size than number of frames are requested
BKFrame frames [512 * 2];

// Generate 512 frames e.g. as they would be requested by an audio output function
// Subsequent calls to this function generates the next requested number of frames
BKContextGenerate (& ctx, frames, 512);
{% endhighlight %}

### Attributes

The behaviour of objects is controlled by *attributes*. The attribute values can be integer values or pointers, which can either be other objects or structs.

Attributes of a track may be the note which is playing, or the volume. Some few attributes are read-only. For example, the number of channels of a context. All writable attributes can be changed even while the generator functions are running. For this purpose, clocks and dividers are used.

### Clocks and dividers

The context object contains a master clocks which has a tick rate of 240 Hz by default. All effects are timed by this clock.

To create a simple beat for example, the note attribute may be changed at every 120th tick, which accords to 0.5 seconds. To achieve this, the [`BKDivider`](clocks/) object is used.

{% highlight c %}
// Divider object
BKDivider divider;

// The callback struct is only used for initializing the divider
BKDividerCallback callback;

// Set callback function
callback.func     = dividerCallback;
callback.userInfo = NULL;

// Initialize divider object with a value of 120
BKDividerInit (& divider, 120, & callback);

// Attach the divider to the context's master clock
// When frames are generated the callback is called at the defined interval
BKContextAttachDivider (& ctx, & divider, BK_CLOCK_TYPE_BEAT);
{% endhighlight %}

{% highlight c %}
BKEnum dividerCallback (BKCallbackInfo * info, void * userInfo)
{
	return 0;
}
{% endhighlight %}
