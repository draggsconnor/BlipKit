---
layout: doc
title: Manual
order: 10
description: This is an overview of the library's concept and its basic objects. Basically, all object variables are declared statically. This way, memory allocations can be optimized.
---

This is an overview of the library's concept and its basic objects. Basically, all object variables are declared statically. This way, memory allocations can be optimized for the own needs.

*Although the objects in the example code snippets are declared in a function-like context, it should be remembered to declare them globally or wrapped inside other objects so they exist further when a function returns.*

- [Context Object](#context-object)
- [Track Objects](#track-objects)
- [Attributes](#attributes)
- [Playing a Note](#playing-a-note)
- [Generating Audio Data](#generating-audio-data)
- [Creating a Beat](#creating-a-beat)

## Context Object

[BKContext](context/) is the base object. The number of needed channels is defined at initialization (usually 2 for stereo). The sample rate should match that one which is used to output the audio, otherwise speed and pitch will not match.

{% highlight c %}
// The context object
BKContext ctx;

// Initialize a context object with 2 channels (stereo)
// and a sample rate of 44100 Hz
BKContextInit (& ctx, 2, 44100);
{% endhighlight %}

## Track Objects

[BKTrack](tracks/) objects render the audio data. This may be a [waveform](waveforms/) or a [sample](samples/). A waveform type has to be given at initialization which can be changed afterwards, though. Each track generates it own layer of audio data and does not interfere with other tracks.

{% highlight c %}
// The track object
BKTrack track;

// Initialize a track object with a square wave
BKTrackInit (& track, BK_SQUARE);
{% endhighlight %}

In order to include a track into the rendering chain, it has to be attached to a context. Each context may have an arbitrary number of tracks attached to it.

{% highlight c %}
// Attach track to context
BKTrackAttach (& track, & ctx);
{% endhighlight %}

## Attributes

*Attributes* control the behaviour of objects. They can be single integers or pointers, which can either be other objects or structs. Each object has its own setter and getter functions to write and read its attributes.

- [Track attributes](tracks/#attributes)
- [Context attributes](context/#attributes)

## Playing a Note

A track can only play one note at once. The `BK_NOTE` attribute sets the track's note which is a [fixed-point number](fixed-point-numbers/) that also allows to use fractional notes.

{% highlight c %}
// Set note C of octave 3
BKTrackSetAttr (& track, BK_NOTE, BK_C_3 * BK_FINT20_UNIT);
{% endhighlight %}

The constants `BK_C_0` to `BK_C_8` are values between 0 and 96 and used for readability. Of course, their equivalent integer values can be used as well for setting notes.

To unset the note, it can either be set to `BK_NOTE_RELEASE` or `BK_NOTE_MUTE`. The latter has a different behaviour when using [instruments](instruments/); it does not play the envelopes' release parts and mutes the note immediately.

The release constants `BK_NOTE_RELEASE` and `BK_NOTE_MUTE` must **not** be multiplied by `BK_FINT20_UNIT`.

{% highlight c %}
// Release note
BKTrackSetAttr (& track, BK_NOTE, BK_NOTE_RELEASE);
{% endhighlight %}

## Generating Audio Data

Audio data is generated by requesting an arbitary number of *frames*. This is done by calling either [BKContextGenerate](../context/#bkcontextgenerate), which fills a provided buffer with the requested frames, or its variant [BKContextGenerateToTime](../context/#bkcontextgeneratetotime), which outputs the frames to a provided callback.

A call to one of this functions advances each attached track's time by running its render function. The generated audio data of each tracks is then merged into the audio buffer. Subsequent calls to the generator functions generate the next requested number of frames.

{% highlight c %}
// Define an audio data buffer
// As there are two channels used, the buffer actually must be
// two times the size than number of frames are requested
BKFrame frames [512 * 2];

// Generate 512 frames e.g. as they would be requested by an audio output function
// Subsequent calls to this function generates the next requested number of frames
BKContextGenerate (& ctx, frames, 512);

// The channels are interlaced into the buffer in the form: LRLR...
// Which means that the first frame of the left channel is at frames[0],
// the first frame of the right channel at frames[1] and so on
{% endhighlight %}

## Creating a Beat

The context object contains a master clock which has a tick rate of 240 Hz. This *ticks* are the base for [effects](effects/), [instruments](../instruments/) and [arpeggio notes](arepggio/).

<!--[[[BKDivider](clocks-and-dividers/) objects reduce the tick rate by a given factor by calling a provided callback every specific number of tick of the master clock.]]-->

{% highlight c %}
// Divider object
BKDivider divider;

// The callback struct is only used for initializing the divider
BKDividerCallback callback;

// Set callback function
callback.func     = dividerCallback;
callback.userInfo = NULL;

// Initialize divider object with a value of 60
// The callback is called every 60th tick of the master clock
BKDividerInit (& divider, 60, & callback);

// Attach the divider to the context's master clock
// When frames are generated the callback is called at the defined interval points
BKContextAttachDivider (& ctx, & divider, BK_CLOCK_TYPE_BEAT);
{% endhighlight %}

The callback function receives two arguments. The first one contains the `BKDivider` object and information about the event. The second one is the user defined pointer given at initialization. The function should always return 0 as there are no other values defined at the moment.

{% highlight c %}
BKEnum dividerCallback (BKCallbackInfo * info, void * userInfo)
{
	BKDivider * divider = info -> object;

	// Update track attributes ...

	return 0;
}
{% endhighlight %}

<!--
To create a beat with a certain BPM the divider interval can be calculated with this formula:

{% highlight c %}
ticks_per_beat = (240 × 60) / (bpm × 4);
{% endhighlight %}

As divider intervals are integers, only certain BPM values are possible without changing the master clock tick rate. For a BPM of 150 the divider interval is exactly 24.

{% highlight c %}
bpm = (240 × 60) / (ticks_per_beat × 4)
{% endhighlight %}
-->
