---
layout: doc
title: Manual
order: 10
---

- [Context object](#context-object)
- [Track objects](#track-objects)
- [Generating audio data](#generating-audio-data)
- [Attributes](#attributes)
- [Dividers](#dividers)

## Context object

[BKContext](context/) is the base object and controls the audio rendering. The number of required channels is defined at initialization (e.g. 2 for stereo). The sample rate should match that one which is used to output the audio, otherwise speed and pitch will not match.

{% highlight c %}
BKContext ctx;

// Initialize a context object with 2 channels (stereo)
// and a sample rate of 44100 Hz
BKContextInit (& ctx, 2, 44100);
{% endhighlight %}

## Track objects

[BKTrack](tracks/) objects render the audio data. This may be a [waveform](waveforms/) or a [sample](samples/). A waveform type has to be given at initialization, which can be changed afterwards, though. Each track generates it own layer of sound data and doesn't interfere with other tracks.

{% highlight c %}
BKTrack track;

// Initialize a track object with a square wave
BKTrackInit (& track, BK_SQUARE);
{% endhighlight %}

In order to include a track into the rendering process, it has to be attached to a context. Each context may have an arbitrary number of tracks attached to it.

{% highlight c %}
// Attach track to context
BKTrackAttach (& track, & ctx);
{% endhighlight %}

## Generating audio data

Audio data is generated by requesting an arbitary number of frames. This is done by calling either [BKContextGenerate](../context/#bkcontextgenerate), which fills a provided buffer with the requested frames, or its variant [BKContextGenerateToTime](../context/#bkcontextgeneratetotime), which outputs the frames to a provided callback.

A call to one of this functions advances each attached track's time by running its render function. The generated audio data of each tracks is then merged into the audio buffer. Subsequent calls to the generator functions generate the next requested number of frames.

{% highlight c %}
// Define an audio data buffer
// As there are two channels used, the buffer actually must be
// two times the size than number of frames are requested
BKFrame frames [512 * 2];

// Generate 512 frames e.g. as they would be requested by an audio output function
// Subsequent calls to this function generates the next requested number of frames
BKContextGenerate (& ctx, frames, 512);

// The channels are interlaced into the buffer in the form: LRLR...
// Which means that the first frame of the left channel is at frames[0],
// the first frame of the right channel at frames[1] and so on
{% endhighlight %}

## Attributes

The behaviour of objects, including tracks, is controlled by *attributes*. Attribute values can be integers or pointers, which can either be other objects or structs.

Some few attributes are read-only. For example, the number of channels of a context. All writable attributes can be changed even while the generator functions are running. For this purpose, [BKDivider](clocks/) objects are used.

## Dividers

The context object contains a master clock which has a tick rate of 240 Hz by default. All effects and arpeggio notes are timed by this clock. [BKDivider](clocks/) objects can be attached to the clock and call a provided callback in a certain interval.

{% highlight c %}
// Divider object
BKDivider divider;

// The callback struct is only used for initializing the divider
BKDividerCallback callback;

// Set callback function
callback.func     = dividerCallback;
callback.userInfo = NULL;

// Initialize divider object with a value of 60
// The callback is called every 60th tick of the master clock
BKDividerInit (& divider, 60, & callback);

// Attach the divider to the context's master clock
// When frames are generated the callback is called at the defined interval points
BKContextAttachDivider (& ctx, & divider, BK_CLOCK_TYPE_BEAT);
{% endhighlight %}

The callback function receives two arguments. The first one contains general informations about the event. The second one contains a user defined pointer. The function should always return 0 as there are no other values defined at the moment.

{% highlight c %}
BKEnum dividerCallback (BKCallbackInfo * info, void * userInfo)
{
	// Update track attributes ...

	return 0;
}
{% endhighlight %}

<!--
To create a beat with a certain BPM the divider interval can be calculated with this formula:

{% highlight c %}
ticks_per_beat = (240 × 60) / (bpm × 4);
{% endhighlight %}

As divider intervals are integers, only certain BPM values are possible without changing the master clock tick rate. For a BPM of 150 the divider interval is exactly 24.

{% highlight c %}
bpm = (240 × 60) / (ticks_per_beat × 4)
{% endhighlight %}
-->
